# 详细测试方法指南

## 📋 目录
1. [单模块测试方法](#单模块测试方法)
2. [模块集成测试](#模块集成测试)
3. [完整功能测试](#完整功能测试)
4. [问题排查指南](#问题排查指南)

---

## 单模块测试方法

### 成员一：MessageDispatcher + NetworkDiscovery

#### MessageDispatcher 测试

**测试文件**：创建 `tests/test_dispatcher.py`

```python
import sys
import time
from PyQt6.QtWidgets import QApplication
from src.common.message_types import Member, ChatMessage, MessageType
from src.core.message_dispatcher import MessageDispatcher

def test_dispatcher():
    """测试消息分发器基本功能"""
    app = QApplication(sys.argv)
    
    # 创建本地成员
    local_member = Member("TestUser", "127.0.0.1", 8888, 8889)
    
    # 创建分发器
    dispatcher = MessageDispatcher(local_member)
    
    # 测试1：启动服务
    print("测试1：启动MessageDispatcher...")
    dispatcher.start()
    time.sleep(1)
    assert dispatcher.is_running == True
    print("✓ 启动成功")
    
    # 测试2：发送广播消息
    print("\n测试2：发送广播消息...")
    message = ChatMessage(
        msg_type=MessageType.DISCOVERY,
        sender=local_member,
        content="TEST"
    )
    result = dispatcher.broadcast_message(message.to_dict())
    assert result == True
    print("✓ 广播发送成功")
    
    # 测试3：停止服务
    print("\n测试3：停止MessageDispatcher...")
    dispatcher.stop()
    time.sleep(1)
    assert dispatcher.is_running == False
    print("✓ 停止成功")
    
    print("\n✅ MessageDispatcher 所有测试通过！")

if __name__ == '__main__':
    test_dispatcher()
```

**运行测试**：
```bash
python tests/test_dispatcher.py
```

**预期结果**：
- ✅ 能够创建UDP socket
- ✅ 能够绑定到8888端口
- ✅ 能够发送广播消息
- ✅ 能够正常停止服务

#### NetworkDiscovery 测试

**测试文件**：创建 `tests/test_discovery.py`

```python
import sys
import time
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QTimer
from src.common.message_types import Member
from src.core.message_dispatcher import MessageDispatcher
from src.core.network_discovery import NetworkDiscovery

class DiscoveryTester:
    def __init__(self):
        self.discovered_members = []
    
    def on_member_discovered(self, member):
        print(f"✓ 发现成员: {member.username} ({member.ip})")
        self.discovered_members.append(member)

def test_discovery():
    """测试网络发现功能"""
    app = QApplication(sys.argv)
    
    # 创建两个实例模拟P2P
    member1 = Member("User1", "127.0.0.1", 8888, 8889)
    member2 = Member("User2", "127.0.0.1", 8890, 8891)
    
    # 实例1
    dispatcher1 = MessageDispatcher(member1)
    discovery1 = NetworkDiscovery(member1, dispatcher1)
    tester1 = DiscoveryTester()
    discovery1.member_discovered.connect(tester1.on_member_discovered)
    
    # 启动实例1
    dispatcher1.start()
    dispatcher1.discovery_message.connect(discovery1.handle_message)
    
    print("测试：发送发现广播...")
    discovery1.send_discovery_broadcast()
    
    # 等待响应
    QTimer.singleShot(2000, app.quit)
    app.exec()
    
    # 清理
    dispatcher1.stop()
    
    print("\n✅ NetworkDiscovery 测试完成！")

if __name__ == '__main__':
    test_discovery()
```

**预期结果**：
- ✅ 能够发送发现广播
- ✅ 能够接收并响应发现请求
- ✅ 能够触发 member_discovered 信号

---

### 成员七：MessageP2P 测试

**测试文件**：`tests/test_p2p.py`

```python
import sys
import time
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QTimer
from src.common.message_types import Member, ChatMessage
from src.core.message_dispatcher import MessageDispatcher
from src.core.message_p2p import MessageP2P

class P2PTester:
    def __init__(self, name):
        self.name = name
        self.received_messages = []
    
    def on_message_received(self, message):
        print(f"✓ {self.name} 收到消息: {message.content}")
        self.received_messages.append(message)

def test_p2p():
    """测试一对一消息"""
    app = QApplication(sys.argv)
    
    # 创建两个用户
    user1 = Member("Alice", "127.0.0.1", 8888, 8889)
    user2 = Member("Bob", "127.0.0.1", 8888, 8889)  # 同端口测试
    
    # 创建dispatcher和p2p模块
    dispatcher1 = MessageDispatcher(user1)
    p2p1 = MessageP2P(user1, dispatcher1)
    tester1 = P2PTester("Alice")
    p2p1.message_received.connect(tester1.on_message_received)
    
    # 启动
    dispatcher1.start()
    dispatcher1.p2p_message.connect(p2p1.handle_message)
    
    # 发送消息（给自己，回环测试）
    print("测试：发送P2P消息...")
    success = p2p1.send_p2p_message(user1, "Hello, this is a test!")
    
    if success:
        print("✓ 消息发送成功")
    
    # 等待接收
    QTimer.singleShot(1000, app.quit)
    app.exec()
    
    # 验证
    assert len(tester1.received_messages) > 0, "应该收到消息"
    print(f"✓ 收到 {len(tester1.received_messages)} 条消息")
    
    # 清理
    dispatcher1.stop()
    
    print("\n✅ MessageP2P 测试通过！")

if __name__ == '__main__':
    test_p2p()
```

**预期结果**：
- ✅ 能够发送P2P消息
- ✅ 能够接收P2P消息
- ✅ 消息内容正确
- ✅ 触发 message_received 信号

---

### 成员三：MessageBroadcast 测试

**测试要点**：
1. 能够向成员列表中的所有成员发送消息
2. 能够接收并处理广播消息
3. 触发 broadcast_received 信号

**测试命令**：
```python
# 创建测试实例
broadcast = MessageBroadcast(local_member, dispatcher)

# 设置成员列表
members = [member1, member2, member3]
broadcast.update_member_list(members)

# 发送广播
broadcast.send_broadcast_message("Hello everyone!")

# 验证每个成员都收到消息
```

---

### 成员四：FileTransfer 测试

**测试文件**：`tests/test_file_transfer.py`

```python
import os
from src.core.file_transfer import FileTransfer
from src.common.message_types import Member

def test_file_transfer():
    """测试文件传输"""
    
    # 创建测试文件
    test_file = "test_data.txt"
    with open(test_file, 'w') as f:
        f.write("This is a test file content.")
    
    # 创建发送方和接收方
    sender = Member("Sender", "127.0.0.1", 8888, 8889)
    receiver = Member("Receiver", "127.0.0.1", 8888, 8890)
    
    # 创建文件传输实例
    file_transfer_sender = FileTransfer(sender)
    file_transfer_receiver = FileTransfer(receiver)
    
    # 启动接收方
    file_transfer_receiver.start()
    
    # 发送文件
    print("测试：发送文件...")
    file_transfer_sender.send_file(test_file, receiver)
    
    # 等待传输完成
    import time
    time.sleep(3)
    
    # 验证文件是否接收
    received_file = f"downloads/{test_file}"
    assert os.path.exists(received_file), "文件应该被接收"
    print("✓ 文件传输成功")
    
    # 清理
    os.remove(test_file)
    if os.path.exists(received_file):
        os.remove(received_file)
    
    print("\n✅ FileTransfer 测试通过！")

if __name__ == '__main__':
    test_file_transfer()
```

**预期结果**：
- ✅ TCP服务器能够启动
- ✅ 能够建立TCP连接
- ✅ 文件能够分块传输
- ✅ 进度更新正确
- ✅ 文件完整性验证通过

---

### 成员五：MemberManager 测试

**测试命令**：
```python
# 测试添加成员
manager = MemberManager(local_member, dispatcher)

# 测试1：添加成员
new_member = Member("User1", "192.168.1.100", 8888, 8889)
manager.add_member(new_member)
assert new_member in manager.get_member_list()
print("✓ 添加成员成功")

# 测试2：检查重复
manager.add_member(new_member)  # 不应该重复添加
assert manager.get_member_list().count(new_member) == 1
print("✓ 重复检查正确")

# 测试3：移除成员
manager.remove_member(new_member)
assert new_member not in manager.get_member_list()
print("✓ 移除成员成功")

# 测试4：广播加入
manager.broadcast_join()  # 应该成功发送
print("✓ 广播加入成功")
```

**预期结果**：
- ✅ 能够添加成员
- ✅ 能够检测重复成员
- ✅ 能够移除成员
- ✅ 能够触发 member_list_updated 信号
- ✅ 能够广播 JOIN/LEAVE 消息

---

### 成员六：MemberRefresh 测试

**测试要点**：
1. 点击刷新按钮触发刷新
2. 发送REFRESH广播
3. 接收响应并更新成员列表
4. 防止重复刷新

**测试命令**：
```python
refresh = MemberRefresh(local_member, dispatcher)

# 测试刷新
refresh.refresh_members()
assert refresh.is_refreshing == True
print("✓ 刷新状态正确")

# 等待完成
time.sleep(3)
# refresh_completed 信号应该被触发
```

---

### 成员二：MainWindow 测试

**测试方法**：运行完整程序

```bash
python run.py
```

**测试清单**：
1. ✅ 窗口能够正常显示
2. ✅ 用户名输入框出现
3. ✅ 本地IP正确显示
4. ✅ 所有模块正确初始化
5. ✅ 信号连接无错误
6. ✅ 初始发现广播发送成功

---

## 模块集成测试

### 测试1：发现 + 成员管理集成

**测试步骤**：
1. 启动第一个客户端A
2. 启动第二个客户端B
3. 验证A和B互相发现
4. 验证成员列表正确更新

**预期结果**：
- ✅ A的成员列表包含B
- ✅ B的成员列表包含A
- ✅ 成员信息（用户名、IP、端口）正确

### 测试2：消息 + 界面集成

**测试步骤**：
1. 在A的成员列表中选择B
2. 输入消息"Hello B"
3. 点击发送
4. 在B的聊天窗口验证收到消息

**预期结果**：
- ✅ A能够选择目标成员
- ✅ 消息发送成功
- ✅ B收到消息并显示在聊天窗口
- ✅ 消息格式正确（发送者、内容）

### 测试3：广播 + 界面集成

**测试步骤**：
1. 启动3个客户端A、B、C
2. A发送广播消息"Hello everyone"
3. 验证B和C都收到

**预期结果**：
- ✅ B和C的聊天窗口都显示A的广播
- ✅ 消息标记为广播类型

---

## 完整功能测试

### 场景1：新用户加入

**步骤**：
1. 已有客户端A和B在线
2. 启动新客户端C
3. C发送发现广播
4. A和B响应
5. C的成员列表更新

**验证点**：
- ✅ C能够发现A和B
- ✅ A和B也能发现C
- ✅ 所有成员列表保持一致

### 场景2：完整通信流程

**步骤**：
1. A、B、C三个客户端在线
2. A向B发送P2P消息"Hi B"
3. A发送广播"Hello all"
4. B向C发送P2P消息"Hi C"

**验证点**：
- ✅ B只收到A的P2P消息
- ✅ 所有人都收到A的广播
- ✅ C只收到B的P2P消息
- ✅ 消息不会串

### 场景3：文件传输

**步骤**：
1. A选择B作为接收方
2. A选择文件test.pdf
3. 点击发送文件
4. B收到请求并接受
5. 文件传输完成

**验证点**：
- ✅ B收到文件传输请求
- ✅ 文件名和大小正确显示
- ✅ 传输进度条正常更新
- ✅ 文件完整接收到downloads目录
- ✅ 文件内容正确（MD5验证）

### 场景4：用户离开

**步骤**：
1. A、B、C在线
2. B关闭程序
3. 验证A和C的成员列表

**验证点**：
- ✅ B发送LEAVE广播
- ✅ A和C收到离开通知
- ✅ A和C的列表中移除B

### 场景5：手动刷新

**步骤**：
1. A、B、C在线
2. 网络短暂中断后恢复
3. A点击刷新按钮
4. 验证成员列表更新

**验证点**：
- ✅ 刷新广播发送
- ✅ 在线成员响应
- ✅ 成员列表正确更新
- ✅ 离线成员不出现

---

## 问题排查指南

### 问题1：无法发现其他成员

**可能原因**：
- UDP端口被占用
- 防火墙阻止
- 不在同一网络

**排查步骤**：
1. 检查端口：`netstat -an | grep 8888`
2. 临时关闭防火墙测试
3. 检查IP地址是否在同一网段
4. 查看控制台日志

### 问题2：消息发送失败

**可能原因**：
- Dispatcher未启动
- 信号未连接
- 目标成员离线

**排查步骤**：
1. 检查 `dispatcher.is_running`
2. 验证信号连接
3. 确认目标成员在列表中
4. 查看发送返回值

### 问题3：文件传输失败

**可能原因**：
- TCP端口被占用
- 文件路径错误
- 权限不足

**排查步骤**：
1. 检查TCP端口是否监听
2. 验证文件存在且可读
3. 检查downloads目录权限
4. 查看传输日志

### 问题4：界面卡顿

**可能原因**：
- 在主线程中执行耗时操作
- 未使用信号槽机制

**解决方法**：
1. 将耗时操作放到工作线程
2. 使用信号槽更新UI
3. 避免在UI线程中阻塞

---

## 测试报告模板

```markdown
## 测试报告 - [模块名] - [姓名]

### 测试日期
2025-XX-XX

### 测试环境
- 操作系统：Windows/Linux/Mac
- Python版本：3.x.x
- PyQt6版本：6.x.x

### 测试项目

#### 1. [测试项目名称]
- **状态**: ✅通过 / ❌失败
- **说明**: ...
- **截图**: (如有)

#### 2. [测试项目名称]
- **状态**: ✅通过 / ❌失败
- **说明**: ...

### 发现的问题
1. [问题描述]
   - 重现步骤：...
   - 预期结果：...
   - 实际结果：...
   - 解决方案：...

### 总结
- 通过项：X/Y
- 测试结论：✅可以集成 / ⚠️需要修复
```

---

## 性能测试

### 测试1：消息吞吐量
- 在1秒内发送100条消息
- 验证接收率 > 95%

### 测试2：大文件传输
- 传输100MB文件
- 验证传输速度和进度准确性

### 测试3：多用户并发
- 10个用户同时在线
- 验证系统稳定性

---

完成测试后，请填写测试报告并提交给小组！

