# 开发指南

## 模块职责分工

### 成员一：自动发现聊天组（network_discovery.py）

**职责**：
- 通过UDP广播实现客户端间的组员发现与加入
- 更新并维护组员列表
- 正确识别并响应其他客户端的广播消息

**实现要点**：
1. 创建UDP socket并设置SO_BROADCAST选项
2. 绑定到指定端口（DEFAULT_UDP_PORT）
3. 在独立线程中持续监听UDP消息
4. 发送包含关键字的发现广播
5. 接收到发现请求时，返回本地成员信息
6. 接收到响应时，触发member_discovered信号

**关键函数**：
- `start()`: 启动服务，创建socket并开始监听
- `send_discovery_broadcast()`: 发送发现广播
- `_listen_loop()`: 监听循环（线程函数）
- `_handle_discovery_request()`: 处理发现请求
- `_handle_discovery_response()`: 处理发现响应

---

### 成员二：一对一消息传输（message_p2p.py）

**职责**：
- 实现客户端之间一对一即时消息的发送和接收
- 确保消息能够正确显示在接收方界面

**实现要点**：
1. 使用共享的UDP socket发送消息
2. 构造P2P_MESSAGE类型的ChatMessage
3. 序列化消息为JSON格式
4. 发送到目标成员的IP和端口
5. 接收并处理P2P消息，触发message_received信号

**关键函数**：
- `send_p2p_message(receiver, content)`: 发送一对一消息
- `handle_received_message(data, addr)`: 处理接收到的消息

---

### 成员三：广播消息（message_broadcast.py）

**职责**：
- 实现客户端间的广播消息功能
- 确保每个在线客户端能够接收并展示广播消息

**实现要点**：
1. 维护最新的成员列表
2. 构造BROADCAST_MESSAGE类型的消息
3. 遍历所有在线成员，逐个发送消息
4. 接收并处理广播消息，触发broadcast_received信号

**关键函数**：
- `update_member_list(members)`: 更新成员列表
- `send_broadcast_message(content)`: 发送广播消息
- `handle_broadcast_message(data, addr)`: 处理接收的广播消息

---

### 成员四：文件传输（file_transfer.py）

**职责**：
- 实现文件选择、分块发送
- 实现基于TCP协议的文件传输
- 支持进度条展示和文件接收

**实现要点**：
1. 创建TCP socket并监听连接
2. 发送文件：
   - 连接到接收方TCP端口
   - 发送文件信息（文件名、大小）
   - 等待接收方确认
   - 分块读取并发送文件
   - 更新传输进度
3. 接收文件：
   - 接受TCP连接
   - 接收文件信息
   - 触发file_request_received信号让用户确认
   - 接收并保存文件数据
   - 更新传输进度

**关键函数**：
- `start()`: 启动TCP监听服务
- `send_file(file_path, receiver)`: 发送文件
- `_send_file_thread()`: 发送文件的线程函数
- `_listen_loop()`: 监听TCP连接
- `_handle_client()`: 处理客户端连接（接收文件）
- `accept_file()/reject_file()`: 接受/拒绝文件传输

---

### 成员五：组员管理（member_manager.py）

**职责**：
- 实现组员的管理功能
- 处理成员发现、加入、退出的管理
- 处理组员退出时的广播通知
- 更新与展示组员列表

**实现要点**：
1. 维护成员列表（List[Member]）
2. 添加成员时检查重复
3. 触发相应的信号通知UI更新
4. 广播JOIN/LEAVE消息
5. 处理其他成员的JOIN/LEAVE消息

**关键函数**：
- `add_member(member)`: 添加成员
- `remove_member(member)`: 移除成员
- `get_member_list()`: 获取成员列表
- `get_member_by_ip(ip, port)`: 根据IP查找成员
- `broadcast_join()/broadcast_leave()`: 广播加入/离开消息
- `handle_join_message()/handle_leave_message()`: 处理加入/离开消息

---

### 成员六：手动刷新组员列表（member_refresh.py）

**职责**：
- 实现手动刷新功能
- 当用户点击刷新按钮时，通过广播重新查找并更新组员列表
- 确保刷新后的组员列表能够在界面中即时显示

**实现要点**：
1. 发送REFRESH类型的广播消息
2. 设置刷新标志，防止重复刷新
3. 收集响应，统计发现的成员数
4. 触发refresh_completed信号
5. 处理其他成员的刷新请求，返回本地信息

**关键函数**：
- `refresh_members()`: 发起刷新
- `handle_refresh_request(sender_addr)`: 处理刷新请求
- `handle_refresh_response(message)`: 处理刷新响应

---

### 成员七：界面整合与设计（main_window.py）

**职责**：
- 整合各个功能模块
- 设计用户界面（聊天窗口、组员列表、消息输入框、文件传输进度条等）
- 确保所有功能都能在界面中流畅运行
- 界面简洁易用

**实现要点**：
1. 创建主窗口布局
2. 初始化所有核心模块
3. 连接信号和槽函数
4. 实现各个按钮的事件处理
5. 更新UI显示（成员列表、聊天记录、进度条）
6. 处理窗口关闭事件，清理资源

**关键函数**：
- `init_ui()`: 初始化界面
- `create_member_panel()`: 创建成员面板
- `create_chat_panel()`: 创建聊天面板
- `init_modules()`: 初始化核心模块
- `connect_signals()`: 连接信号槽
- 各种槽函数：`on_refresh_members()`, `on_send_message()`, 等

---

## 开发流程

### 1. 环境搭建
```bash
# 克隆仓库
git clone <repository_url>
cd computer_network_experiment

# 安装依赖
pip install -r requirements.txt
```

### 2. 创建开发分支
```bash
git checkout -b feature/module-name
```

### 3. 实现功能
- 找到你负责的模块文件
- 查找标注 `TODO: 成员X实现` 的部分
- 实现相关功能
- 添加必要的错误处理

### 4. 本地测试
```bash
python run.py
```

### 5. 提交代码
```bash
git add .
git commit -m "实现XXX功能"
git push origin feature/module-name
```

### 6. 合并代码
- 创建Pull Request
- 代码审查
- 合并到主分支

---

## 技术细节

### UDP广播实现

```python
# 创建UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 设置广播选项
sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
# 设置地址重用
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# 绑定端口
sock.bind(('', DEFAULT_UDP_PORT))
# 发送广播
sock.sendto(data, ('255.255.255.255', DEFAULT_UDP_PORT))
```

### TCP文件传输

```python
# 服务端
server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_sock.bind(('', DEFAULT_TCP_PORT))
server_sock.listen(5)
client_sock, addr = server_sock.accept()

# 客户端
client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_sock.connect((target_ip, DEFAULT_TCP_PORT))
```

### 消息序列化

```python
# 序列化
message_dict = message.to_dict()
data = serialize_message(message_dict)

# 反序列化
message_dict = deserialize_message(data)
message = ChatMessage.from_dict(message_dict)
```

### PyQt6信号槽

```python
# 定义信号
class MyClass(QObject):
    my_signal = pyqtSignal(str)
    
    def emit_signal(self):
        self.my_signal.emit("Hello")

# 连接槽
obj = MyClass()
obj.my_signal.connect(my_slot_function)
```

---

## 调试技巧

1. **使用print调试**：在关键位置添加print语句
2. **日志记录**：使用logging模块记录运行日志
3. **网络抓包**：使用Wireshark查看网络数据包
4. **多实例测试**：在同一局域网运行多个客户端测试
5. **异常捕获**：添加try-except捕获并打印异常信息

---

## 注意事项

1. **线程安全**：涉及多线程的地方注意同步
2. **资源清理**：程序退出时正确关闭socket和线程
3. **异常处理**：网络操作要有完善的异常处理
4. **编码问题**：统一使用UTF-8编码
5. **端口占用**：确保端口未被占用
6. **防火墙**：测试时注意防火墙设置

---

## 联调建议

1. **先实现基础功能**：网络发现 → 消息传输 → 文件传输
2. **模块独立测试**：每个模块先单独测试
3. **接口对接**：确保各模块间的接口一致
4. **集成测试**：所有模块完成后进行集成测试
5. **压力测试**：测试多用户场景和大文件传输

